/* (mostly)automatically generated by rust-bindgen */
#[allow(dead_code)];

#[cfg(target_arch = "x86_64")]
use num::complex::Cmplx;

use std::libc::{c_void, c_int, c_uint, c_float,
                c_long, FILE, size_t, c_double};

pub static FFTW_FORWARD: c_int = -1;
pub static FFTW_BACKWARD: c_int = 1;
pub static FFTW_NO_TIMELIMIT: c_float = -1.0;
pub static FFTW_MEASURE: c_uint = 0;
pub static FFTW_DESTROY_INT: c_uint = 1 << 0;
pub static FFTW_UNALIGNED: c_uint = 1 << 1;
pub static FFTW_CONSERVE_MEMORY: c_uint = 1 << 2;
pub static FFTW_EXHSTIVE: c_uint = 1 << 3; /* NO_EXHSTIVE is default */
pub static FFTW_PRESERVE_INT: c_uint = 1 << 4; /* cancels FFTW_DESTROY_INT */
pub static FFTW_PATIENT: c_uint = 1 << 5; /* IMPATIENT is default */
pub static FFTW_ESTIMATE: c_uint = 1 << 6;

pub static FFTW_R2HC: c_uint = 0;
pub static FFTW_HC2R: c_uint = 1;
pub static FFTW_DHT: c_uint = 2;
pub static FFTW_REDFT00: c_uint = 3;
pub static FFTW_REDFT01: c_uint = 4;
pub static FFTW_REDFT10: c_uint = 5;
pub static FFTW_REDFT11: c_uint = 6;
pub static FFTW_RODFT00: c_uint = 7;
pub static FFTW_RODFT01: c_uint = 8;
pub static FFTW_RODFT10: c_uint = 9;
pub static FFTW_RODFT11: c_uint = 10;

pub type ptrdiff_t = c_long;
pub type wchar_t = c_int;

#[cfg(target_arch = "x86_64")]
pub type fftw_complex = Cmplx<f64>;

#[cfg(not(target_arch = "x86_64"))]
pub type fftw_complex =[c_double, ..2u];

pub type Struct_fftw_plan_s = c_void;
pub type fftw_plan = *mut Struct_fftw_plan_s;
pub type fftwf_complex = [c_float, ..2u];
pub type Struct_fftwf_plan_s = c_void;
pub type fftwf_plan = *mut Struct_fftwf_plan_s;
pub type fftwl_complex = [c_double, ..2u];
pub type Struct_fftwl_plan_s = c_void;
pub type fftwl_plan = *mut Struct_fftwl_plan_s;
#[link(name = "fftw3")]
extern "C" {
    pub fn fftw_execute(p: fftw_plan);
    pub fn fftw_plan_dft(rank: c_int, n: *c_int, _in: *mut fftw_complex,
                         out: *mut fftw_complex, sign: c_int, flags: c_uint)
     -> fftw_plan;
    pub fn fftw_plan_dft_1d(n: c_int, _in: *mut fftw_complex,
                            out: *mut fftw_complex, sign: c_int,
                            flags: c_uint) -> fftw_plan;
    pub fn fftw_plan_dft_2d(n0: c_int, n1: c_int, _in: *mut fftw_complex,
                            out: *mut fftw_complex, sign: c_int,
                            flags: c_uint) -> fftw_plan;
    pub fn fftw_plan_dft_3d(n0: c_int, n1: c_int, n2: c_int,
                            _in: *mut fftw_complex, out: *mut fftw_complex,
                            sign: c_int, flags: c_uint) -> fftw_plan;
    pub fn fftw_plan_many_dft(rank: c_int, n: *c_int, howmany: c_int,
                              _in: *mut fftw_complex, inembed: *c_int,
                              istride: c_int, idist: c_int,
                              out: *mut fftw_complex, onembed: *c_int,
                              ostride: c_int, odist: c_int, sign: c_int,
                              flags: c_uint) -> fftw_plan;
    pub fn fftw_execute_dft(p: fftw_plan, _in: *mut fftw_complex,
                            out: *mut fftw_complex);
    pub fn fftw_execute_split_dft(p: fftw_plan, ri: *mut c_double,
                                  ii: *mut c_double, ro: *mut c_double,
                                  io: *mut c_double);
    pub fn fftw_plan_many_dft_r2c(rank: c_int, n: *c_int, howmany: c_int,
                                  _in: *mut c_double, inembed: *c_int,
                                  istride: c_int, idist: c_int,
                                  out: *mut fftw_complex, onembed: *c_int,
                                  ostride: c_int, odist: c_int, flags: c_uint)
     -> fftw_plan;
    pub fn fftw_plan_dft_r2c(rank: c_int, n: *c_int, _in: *mut c_double,
                             out: *mut fftw_complex, flags: c_uint) ->
     fftw_plan;
    pub fn fftw_plan_dft_r2c_1d(n: c_int, _in: *mut c_double,
                                out: *mut fftw_complex, flags: c_uint) ->
     fftw_plan;
    pub fn fftw_plan_dft_r2c_2d(n0: c_int, n1: c_int, _in: *mut c_double,
                                out: *mut fftw_complex, flags: c_uint) ->
     fftw_plan;
    pub fn fftw_plan_dft_r2c_3d(n0: c_int, n1: c_int, n2: c_int,
                                _in: *mut c_double, out: *mut fftw_complex,
                                flags: c_uint) -> fftw_plan;
    pub fn fftw_plan_many_dft_c2r(rank: c_int, n: *c_int, howmany: c_int,
                                  _in: *mut fftw_complex, inembed: *c_int,
                                  istride: c_int, idist: c_int,
                                  out: *mut c_double, onembed: *c_int,
                                  ostride: c_int, odist: c_int, flags: c_uint)
     -> fftw_plan;
    pub fn fftw_plan_dft_c2r(rank: c_int, n: *c_int, _in: *mut fftw_complex,
                             out: *mut c_double, flags: c_uint) -> fftw_plan;
    pub fn fftw_plan_dft_c2r_1d(n: c_int, _in: *mut fftw_complex,
                                out: *mut c_double, flags: c_uint) ->
     fftw_plan;
    pub fn fftw_plan_dft_c2r_2d(n0: c_int, n1: c_int, _in: *mut fftw_complex,
                                out: *mut c_double, flags: c_uint) ->
     fftw_plan;
    pub fn fftw_plan_dft_c2r_3d(n0: c_int, n1: c_int, n2: c_int,
                                _in: *mut fftw_complex, out: *mut c_double,
                                flags: c_uint) -> fftw_plan;
    pub fn fftw_execute_dft_r2c(p: fftw_plan, _in: *mut c_double,
                                out: *mut fftw_complex);
    pub fn fftw_execute_dft_c2r(p: fftw_plan, _in: *mut fftw_complex,
                                out: *mut c_double);
    pub fn fftw_execute_split_dft_r2c(p: fftw_plan, _in: *mut c_double,
                                      ro: *mut c_double, io: *mut c_double);
    pub fn fftw_execute_split_dft_c2r(p: fftw_plan, ri: *mut c_double,
                                      ii: *mut c_double, out: *mut c_double);
    pub fn fftw_destroy_plan(p: fftw_plan);
    pub fn fftw_cleanup();
    pub fn fftw_set_timelimit(t: c_double);
    pub fn fftw_plan_with_nthreads(nthreads: c_int);
    pub fn fftw_init_threads() -> c_int;
    pub fn fftw_cleanup_threads();
    pub fn fftw_fprint_plan(p: fftw_plan, output_file: *mut FILE);
    pub fn fftw_print_plan(p: fftw_plan);
    pub fn fftw_malloc(n: size_t) -> *mut c_void;
    pub fn fftw_alloc_real(n: size_t) -> *mut c_double;
    pub fn fftw_alloc_complex(n: size_t) -> *mut fftw_complex;
    pub fn fftw_free(p: *mut c_void);
    pub fn fftw_flops(p: fftw_plan, add: *mut c_double, mul: *mut c_double,
                      fmas: *mut c_double);
    pub fn fftw_estimate_cost(p: fftw_plan) -> c_double;
    pub fn fftw_cost(p: fftw_plan) -> c_double;
    pub fn fftwf_execute(p: fftwf_plan);
    pub fn fftwf_plan_dft(rank: c_int, n: *c_int, _in: *mut fftwf_complex,
                          out: *mut fftwf_complex, sign: c_int, flags: c_uint)
     -> fftwf_plan;
    pub fn fftwf_plan_dft_1d(n: c_int, _in: *mut fftwf_complex,
                             out: *mut fftwf_complex, sign: c_int,
                             flags: c_uint) -> fftwf_plan;
    pub fn fftwf_plan_dft_2d(n0: c_int, n1: c_int, _in: *mut fftwf_complex,
                             out: *mut fftwf_complex, sign: c_int,
                             flags: c_uint) -> fftwf_plan;
    pub fn fftwf_plan_dft_3d(n0: c_int, n1: c_int, n2: c_int,
                             _in: *mut fftwf_complex, out: *mut fftwf_complex,
                             sign: c_int, flags: c_uint) -> fftwf_plan;
    pub fn fftwf_plan_many_dft(rank: c_int, n: *c_int, howmany: c_int,
                               _in: *mut fftwf_complex, inembed: *c_int,
                               istride: c_int, idist: c_int,
                               out: *mut fftwf_complex, onembed: *c_int,
                               ostride: c_int, odist: c_int, sign: c_int,
                               flags: c_uint) -> fftwf_plan;
    pub fn fftwf_execute_dft(p: fftwf_plan, _in: *mut fftwf_complex,
                             out: *mut fftwf_complex);
    pub fn fftwf_execute_split_dft(p: fftwf_plan, ri: *mut c_float,
                                   ii: *mut c_float, ro: *mut c_float,
                                   io: *mut c_float);
    pub fn fftwf_plan_many_dft_r2c(rank: c_int, n: *c_int, howmany: c_int,
                                   _in: *mut c_float, inembed: *c_int,
                                   istride: c_int, idist: c_int,
                                   out: *mut fftwf_complex, onembed: *c_int,
                                   ostride: c_int, odist: c_int,
                                   flags: c_uint) -> fftwf_plan;
    pub fn fftwf_plan_dft_r2c(rank: c_int, n: *c_int, _in: *mut c_float,
                              out: *mut fftwf_complex, flags: c_uint) ->
     fftwf_plan;
    pub fn fftwf_plan_dft_r2c_1d(n: c_int, _in: *mut c_float,
                                 out: *mut fftwf_complex, flags: c_uint) ->
     fftwf_plan;
    pub fn fftwf_plan_dft_r2c_2d(n0: c_int, n1: c_int, _in: *mut c_float,
                                 out: *mut fftwf_complex, flags: c_uint) ->
     fftwf_plan;
    pub fn fftwf_plan_dft_r2c_3d(n0: c_int, n1: c_int, n2: c_int,
                                 _in: *mut c_float, out: *mut fftwf_complex,
                                 flags: c_uint) -> fftwf_plan;
    pub fn fftwf_plan_many_dft_c2r(rank: c_int, n: *c_int, howmany: c_int,
                                   _in: *mut fftwf_complex, inembed: *c_int,
                                   istride: c_int, idist: c_int,
                                   out: *mut c_float, onembed: *c_int,
                                   ostride: c_int, odist: c_int,
                                   flags: c_uint) -> fftwf_plan;
    pub fn fftwf_plan_dft_c2r(rank: c_int, n: *c_int, _in: *mut fftwf_complex,
                              out: *mut c_float, flags: c_uint) -> fftwf_plan;
    pub fn fftwf_plan_dft_c2r_1d(n: c_int, _in: *mut fftwf_complex,
                                 out: *mut c_float, flags: c_uint) ->
     fftwf_plan;
    pub fn fftwf_plan_dft_c2r_2d(n0: c_int, n1: c_int,
                                 _in: *mut fftwf_complex, out: *mut c_float,
                                 flags: c_uint) -> fftwf_plan;
    pub fn fftwf_plan_dft_c2r_3d(n0: c_int, n1: c_int, n2: c_int,
                                 _in: *mut fftwf_complex, out: *mut c_float,
                                 flags: c_uint) -> fftwf_plan;
    pub fn fftwf_execute_dft_r2c(p: fftwf_plan, _in: *mut c_float,
                                 out: *mut fftwf_complex);
    pub fn fftwf_execute_dft_c2r(p: fftwf_plan, _in: *mut fftwf_complex,
                                 out: *mut c_float);
    pub fn fftwf_execute_split_dft_r2c(p: fftwf_plan, _in: *mut c_float,
                                       ro: *mut c_float, io: *mut c_float);
    pub fn fftwf_execute_split_dft_c2r(p: fftwf_plan, ri: *mut c_float,
                                       ii: *mut c_float, out: *mut c_float);
    pub fn fftwf_destroy_plan(p: fftwf_plan);
    pub fn fftwf_cleanup();
    pub fn fftwf_set_timelimit(t: c_double);
    pub fn fftwf_plan_with_nthreads(nthreads: c_int);
    pub fn fftwf_init_threads() -> c_int;
    pub fn fftwf_cleanup_threads();
    pub fn fftwf_fprint_plan(p: fftwf_plan, output_file: *mut FILE);
    pub fn fftwf_print_plan(p: fftwf_plan);
    pub fn fftwf_malloc(n: size_t) -> *mut c_void;
    pub fn fftwf_alloc_real(n: size_t) -> *mut c_float;
    pub fn fftwf_alloc_complex(n: size_t) -> *mut fftwf_complex;
    pub fn fftwf_free(p: *mut c_void);
    pub fn fftwf_flops(p: fftwf_plan, add: *mut c_double, mul: *mut c_double,
                       fmas: *mut c_double);
    pub fn fftwf_estimate_cost(p: fftwf_plan) -> c_double;
    pub fn fftwf_cost(p: fftwf_plan) -> c_double;
    pub fn fftwl_execute(p: fftwl_plan);
    pub fn fftwl_plan_dft(rank: c_int, n: *c_int, _in: *mut fftwl_complex,
                          out: *mut fftwl_complex, sign: c_int, flags: c_uint)
     -> fftwl_plan;
    pub fn fftwl_plan_dft_1d(n: c_int, _in: *mut fftwl_complex,
                             out: *mut fftwl_complex, sign: c_int,
                             flags: c_uint) -> fftwl_plan;
    pub fn fftwl_plan_dft_2d(n0: c_int, n1: c_int, _in: *mut fftwl_complex,
                             out: *mut fftwl_complex, sign: c_int,
                             flags: c_uint) -> fftwl_plan;
    pub fn fftwl_plan_dft_3d(n0: c_int, n1: c_int, n2: c_int,
                             _in: *mut fftwl_complex, out: *mut fftwl_complex,
                             sign: c_int, flags: c_uint) -> fftwl_plan;
    pub fn fftwl_plan_many_dft(rank: c_int, n: *c_int, howmany: c_int,
                               _in: *mut fftwl_complex, inembed: *c_int,
                               istride: c_int, idist: c_int,
                               out: *mut fftwl_complex, onembed: *c_int,
                               ostride: c_int, odist: c_int, sign: c_int,
                               flags: c_uint) -> fftwl_plan;
    pub fn fftwl_execute_dft(p: fftwl_plan, _in: *mut fftwl_complex,
                             out: *mut fftwl_complex);
    pub fn fftwl_execute_split_dft(p: fftwl_plan, ri: *mut c_double,
                                   ii: *mut c_double, ro: *mut c_double,
                                   io: *mut c_double);
    pub fn fftwl_plan_many_dft_r2c(rank: c_int, n: *c_int, howmany: c_int,
                                   _in: *mut c_double, inembed: *c_int,
                                   istride: c_int, idist: c_int,
                                   out: *mut fftwl_complex, onembed: *c_int,
                                   ostride: c_int, odist: c_int,
                                   flags: c_uint) -> fftwl_plan;
    pub fn fftwl_plan_dft_r2c(rank: c_int, n: *c_int, _in: *mut c_double,
                              out: *mut fftwl_complex, flags: c_uint) ->
     fftwl_plan;
    pub fn fftwl_plan_dft_r2c_1d(n: c_int, _in: *mut c_double,
                                 out: *mut fftwl_complex, flags: c_uint) ->
     fftwl_plan;
    pub fn fftwl_plan_dft_r2c_2d(n0: c_int, n1: c_int, _in: *mut c_double,
                                 out: *mut fftwl_complex, flags: c_uint) ->
     fftwl_plan;
    pub fn fftwl_plan_dft_r2c_3d(n0: c_int, n1: c_int, n2: c_int,
                                 _in: *mut c_double, out: *mut fftwl_complex,
                                 flags: c_uint) -> fftwl_plan;
    pub fn fftwl_plan_many_dft_c2r(rank: c_int, n: *c_int, howmany: c_int,
                                   _in: *mut fftwl_complex, inembed: *c_int,
                                   istride: c_int, idist: c_int,
                                   out: *mut c_double, onembed: *c_int,
                                   ostride: c_int, odist: c_int,
                                   flags: c_uint) -> fftwl_plan;
    pub fn fftwl_plan_dft_c2r(rank: c_int, n: *c_int, _in: *mut fftwl_complex,
                              out: *mut c_double, flags: c_uint) ->
     fftwl_plan;
    pub fn fftwl_plan_dft_c2r_1d(n: c_int, _in: *mut fftwl_complex,
                                 out: *mut c_double, flags: c_uint) ->
     fftwl_plan;
    pub fn fftwl_plan_dft_c2r_2d(n0: c_int, n1: c_int,
                                 _in: *mut fftwl_complex, out: *mut c_double,
                                 flags: c_uint) -> fftwl_plan;
    pub fn fftwl_plan_dft_c2r_3d(n0: c_int, n1: c_int, n2: c_int,
                                 _in: *mut fftwl_complex, out: *mut c_double,
                                 flags: c_uint) -> fftwl_plan;
    pub fn fftwl_execute_dft_r2c(p: fftwl_plan, _in: *mut c_double,
                                 out: *mut fftwl_complex);
    pub fn fftwl_execute_dft_c2r(p: fftwl_plan, _in: *mut fftwl_complex,
                                 out: *mut c_double);
    pub fn fftwl_execute_split_dft_r2c(p: fftwl_plan, _in: *mut c_double,
                                       ro: *mut c_double, io: *mut c_double);
    pub fn fftwl_execute_split_dft_c2r(p: fftwl_plan, ri: *mut c_double,
                                       ii: *mut c_double, out: *mut c_double);
    pub fn fftwl_destroy_plan(p: fftwl_plan);
    pub fn fftwl_cleanup();
    pub fn fftwl_set_timelimit(t: c_double);
    pub fn fftwl_plan_with_nthreads(nthreads: c_int);
    pub fn fftwl_init_threads() -> c_int;
    pub fn fftwl_cleanup_threads();
    pub fn fftwl_fprint_plan(p: fftwl_plan, output_file: *mut FILE);
    pub fn fftwl_print_plan(p: fftwl_plan);
    pub fn fftwl_malloc(n: size_t) -> *mut c_void;
    pub fn fftwl_alloc_real(n: size_t) -> *mut c_double;
    pub fn fftwl_alloc_complex(n: size_t) -> *mut fftwl_complex;
    pub fn fftwl_free(p: *mut c_void);
    pub fn fftwl_flops(p: fftwl_plan, add: *mut c_double, mul: *mut c_double,
                       fmas: *mut c_double);
    pub fn fftwl_estimate_cost(p: fftwl_plan) -> c_double;
    pub fn fftwl_cost(p: fftwl_plan) -> c_double;
}
